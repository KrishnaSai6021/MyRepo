package com.fmr.batch.ecp.writer;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import org.apache.poi.xssf.usermodel.XSSFRow;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.batch.core.annotation.AfterStep;
import org.springframework.batch.item.Chunk;
import org.springframework.batch.item.ExecutionContext;
import org.springframework.batch.item.ItemStream;
import org.springframework.batch.item.ItemWriter;
import org.springframework.batch.item.file.FlatFileItemWriter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.util.CollectionUtils;

import com.amazonaws.AmazonServiceException;
import com.fmr.batch.ecp.constant.ECPBatchConstant;
import com.fmr.batch.ecp.domain.EcpBatchDomain;
import com.fmr.batch.ecp.domain.EcpOutputRecordBase;
import com.fmr.batch.ecp.domain.EcpOutputRecordSalesForce;
import com.fmr.batch.ecp.service.S3Service;

public class EcpBatchWriter implements ItemWriter<EcpBatchDomain>, ItemStream
{

	/** The Constant LOG. */
	private static final Logger LOG = LoggerFactory.getLogger(EcpBatchWriter.class);

	/** No to hold the Success record count. */
	private int successNum;

	/** No to hold the Success salesforce record count. */
	private int successSalesforceNum;

	/** No to hold the Failure record count. */
	// private int failureNum;

	/** The ecpSuccessFileWriter. */
	@Autowired
	private FlatFileItemWriter<EcpOutputRecordBase> ecpSuccessFileWriter;

	/** The ecpSuccessSalesForceFileWriter. */
	@Autowired
	private FlatFileItemWriter<EcpOutputRecordSalesForce> ecpSuccessSalesForceFileWriter;

	/** The ecpFailureFileWriter. */
	//private FlatFileItemWriter<EcpOutputRecord> ecpFailureFileWriter;

	@Autowired
	private S3Service s3Service;

	@Value("${aws.s3.output-bucket-name}")
	private String outputBucketName;

	@Value("${aws.s3.outputKey}")
	private String outputKey;

	@Value("${aws.s3.outputBaseKey}")
	private String outputBaseKey;

	@Value("${aws.s3.outputSaleKey}")
	private String outputSaleKey;

	/**
	 * The Constructor.
	 */
	public EcpBatchWriter()
	{
		// Default constructor.
	}

	private void putRecordsToList(final List<? extends EcpBatchDomain> items, final List<EcpOutputRecordBase> successList,
								  final List<EcpOutputRecordSalesForce> successSalesForceList)
	{
		items.forEach(ecpBatchDomain -> {
			final List<EcpOutputRecordBase> outputRecords = ecpBatchDomain.getOutputRecordBaseList();
			final List<EcpOutputRecordSalesForce> salesforceOutputRecords = new ArrayList<>();
			if ( ecpBatchDomain.getEcpOutputRecordSalesForce() != null )
			{
				salesforceOutputRecords.add(ecpBatchDomain.getEcpOutputRecordSalesForce());
			}

			if (outputRecords != null && outputRecords.size() > 0)
			{
				successList.addAll(outputRecords);
			}
			if (salesforceOutputRecords != null && salesforceOutputRecords.size() > 0)
			{
				successSalesForceList.addAll(salesforceOutputRecords);
			}

		});
	}

	/**
	 * Method to Open writers.
	 *
	 */
	@Override
	public void open(final ExecutionContext executionContext)
	{
		LOG.info("EcpBatchWriter: open() called");
		this.ecpSuccessFileWriter.open(executionContext);
		this.ecpSuccessSalesForceFileWriter.open(executionContext);

	}

	/**
	 * Method to Update writers.
	 *
	 */
	@Override
	public void update(final ExecutionContext executionContext)
	{
		LOG.info("EcpBatchWriter: update() called");
		this.ecpSuccessFileWriter.update(executionContext);
		this.ecpSuccessSalesForceFileWriter.update(executionContext);
	}

	/**
	 * Method to Close writers.
	 *
	 */
	@Override
	public void close() {
		LOG.info("EcpBatchWriter: close() called");
		final Date timestamp = new Date();
		this.ecpSuccessFileWriter
				.setFooterCallback(new ECPFileFooterCallback(this.getFooter(this.successNum, timestamp)));
		this.ecpSuccessSalesForceFileWriter
				.setFooterCallback(new ECPFileFooterCallback(this.getFooter(this.successSalesforceNum, timestamp)));

		this.ecpSuccessFileWriter.close();
		this.ecpSuccessSalesForceFileWriter.close();

		File fileBase = new File(ECPBatchConstant.ECP_BASE_OUTPUT);
		File fileSales = new File(ECPBatchConstant.ECP_SALES_OUTPUT);

		if (fileBase.exists() && fileSales.exists()) {
			this.writetoS3();
			this.csvSalesOutDataToXLSX();
		}
		this.cleanUpTemporaryFiles();


	}

	private void cleanUpTemporaryFiles() {
		File tempDir = new File("../ecp-batch");
		File[] files = tempDir.listFiles();
		for (File file : files) {
			try {
				if(file.getName().startsWith("ecp_")){
					file.setWritable(true);
					file.delete();
				}
			} catch (SecurityException  e) {
				LOG.error("Unable to perform clean up", e);
			}

		}
	}


	private void writetoS3() {
		File fileBase = new File(ECPBatchConstant.ECP_BASE_OUTPUT);
		File fileSales = new File(ECPBatchConstant.ECP_SALES_OUTPUT);

		try (InputStream targetStreamBase = new FileInputStream(fileBase);
			 InputStream targetStreamSale = new FileInputStream(fileSales)) {

			s3Service.write(this.outputBucketName, outputBaseKey, targetStreamBase);
			s3Service.write(this.outputBucketName, outputSaleKey, targetStreamSale);

		} catch (FileNotFoundException | SecurityException fe) {
			LOG.error("Generated output files not found.", fe.getCause());
		} catch (IOException ioe) {
			LOG.error("Error while closing input stream", ioe);
		} catch (AmazonServiceException e) {
			LOG.error("Error occurred while writing output to S3 bucket.", e.getCause());
		} catch (Exception e) {
			LOG.error("Exception while writing output to S3 bucket.", e.getCause());
		}

	}





	private void csvSalesOutDataToXLSX() {

		try (XSSFWorkbook workBook = new XSSFWorkbook()) {

			File fileSales = new File(ECPBatchConstant.ECP_SALES_OUTPUT);

			String csvSaleFileAddress = fileSales.toPath().toString();

			String xlsxFileAddress = "ecp_batch_" + LocalDate.now().getMonthValue() + LocalDate.now().getDayOfMonth()

					+ LocalDate.now().getYear() + ".xlsx";



			XSSFSheet sheet = workBook.createSheet("sheet1");

			String currentLine = null;

			int RowNum = 0;

			try (BufferedReader br = new BufferedReader(new FileReader(csvSaleFileAddress))) {

				while ((currentLine = br.readLine()) != null) {

					String str[] = currentLine.split("\\|");

					RowNum++;

					XSSFRow currentRow = sheet.createRow(RowNum);

					for (int i = 0; i < str.length; i++) {

						currentRow.createCell(i).setCellValue(str[i]);

					}

				}

			} catch (FileNotFoundException e) {

				LOG.error("Error Reading the sales out csv file.", e);

			}



			FileOutputStream fileOutputStream = new FileOutputStream(xlsxFileAddress);

			workBook.write(fileOutputStream);

			workBook.close();

			fileOutputStream.close();



			File excelSaleFile = new File(xlsxFileAddress);

			InputStream targetStreamExcelSale = new FileInputStream(excelSaleFile);

			try {

				s3Service.write(this.outputBucketName, xlsxFileAddress, targetStreamExcelSale);

				// deleting temporary copy of output files.

				Files.deleteIfExists(excelSaleFile.toPath());

				Files.deleteIfExists(Paths.get(ECPBatchConstant.ECP_FEED_FILE));

				Files.deleteIfExists(new File(ECPBatchConstant.ECP_BASE_OUTPUT).toPath());

				Files.deleteIfExists(fileSales.toPath());

			} catch (AmazonServiceException e) {

				LOG.error("Exception occurred while writing xlsx to S3", e);

			}

		} catch (Exception e) {

			LOG.error("Exception occurred while converting file to xlsx.", e);

		}

	}





//	private void csvSalesOutDataToXLSX() {
//		try {
//			File fileSales = new File(ECPBatchConstant.ECP_SALES_OUTPUT);
//			String csvSaleFileAddress = fileSales.toPath().toString();
//			String xlsxFileAddress = "ecp_batch_" + LocalDate.now().getMonthValue() + LocalDate.now().getDayOfMonth()
//					+ LocalDate.now().getYear() + ".xlsx";
//			XSSFWorkbook workBook = new XSSFWorkbook();
//			XSSFSheet sheet = workBook.createSheet("sheet1");
//			String currentLine = null;
//			int RowNum = 0;
//			try (BufferedReader br = new BufferedReader(new FileReader(csvSaleFileAddress))) {
//				while ((currentLine = br.readLine()) != null) {
//					String str[] = currentLine.split("\\|");
//					RowNum++;
//					XSSFRow currentRow = sheet.createRow(RowNum);
//					for (int i = 0; i < str.length; i++) {
//						currentRow.createCell(i).setCellValue(str[i]);
//					}
//				}
//			} catch (FileNotFoundException e) {
//				LOG.error("Error Reading the sales out csv file.", e);
//			}
//			FileOutputStream fileOutputStream = new FileOutputStream(xlsxFileAddress);
//			workBook.write(fileOutputStream);
//			workBook.close();
//			fileOutputStream.close();
//
//			File excelSaleFile = new File(xlsxFileAddress);
//			InputStream targetStreamExcelSale = new FileInputStream(excelSaleFile);
//			try {
//				s3Service.write(this.outputBucketName, xlsxFileAddress, targetStreamExcelSale);
//				// deleting  temporary copy of output files.
//				Files.deleteIfExists(excelSaleFile.toPath());
//				Files.deleteIfExists(Paths.get(ECPBatchConstant.ECP_FEED_FILE));
//				Files.deleteIfExists(new File(ECPBatchConstant.ECP_BASE_OUTPUT).toPath());
//				Files.deleteIfExists(fileSales.toPath());
//
//			} catch (AmazonServiceException e) {
//				LOG.error("Exception occurred while writing xlsx to S3", e);
//			}
//		} catch (Exception e) {
//			LOG.error("Exception occurred while converting file to xlsx.", e);
//		}
//	}

	/**
	 * Method to get footer details.
	 *
	 * @param successNum
	 *            the number of rows
	 * @param timestamp
	 *            the local date
	 * @return footer details
	 */

	private String getFooter(final int successNum, final Date timestamp) {
		SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		final StringBuilder footer = new StringBuilder(ECPBatchConstant.FOOTER_STAR);
		footer.append(" ");
		footer.append(String.valueOf(successNum));
		footer.append(ECPBatchConstant.PIPE);
		footer.append(simpleDateFormat.format(timestamp));
		footer.append(" ");
		footer.append(ECPBatchConstant.FOOTER_STAR);

		return footer.toString();
	}

	public void setEcpSuccessFileWriter(final FlatFileItemWriter<EcpOutputRecordBase> ecpSuccessFileWriter)
	{
		this.ecpSuccessFileWriter = ecpSuccessFileWriter;
	}

	public void setecpSuccessSalesForceFileWriter(FlatFileItemWriter<EcpOutputRecordSalesForce> ecpSuccessSalesForceFileWriter) {
		this.ecpSuccessSalesForceFileWriter = ecpSuccessSalesForceFileWriter;
	}

	@Override
	public void write(Chunk<? extends EcpBatchDomain> chunk) throws Exception {
		if (chunk.getItems() != null) {
			LOG.info("EcpBatchWriter: writing ECP items. ... Done. Size: {}", chunk.getItems().size());
			if (!CollectionUtils.isEmpty(chunk.getItems())) {
				final List<EcpOutputRecordBase> successList = new ArrayList<>();
				final List<EcpOutputRecordSalesForce> salesForceSuccessList = new ArrayList<>();
				this.putRecordsToList(chunk.getItems(), successList, salesForceSuccessList);

				try {
					if (!CollectionUtils.isEmpty(successList)) {
						synchronized (this.ecpSuccessFileWriter) {
							this.ecpSuccessFileWriter.write(new Chunk(successList));
							this.successNum = this.successNum + successList.size();
							LOG.info("Number of rows written to success file {}", this.successNum);
						}
					}

					if (!CollectionUtils.isEmpty(salesForceSuccessList)) {
						synchronized (this.ecpSuccessSalesForceFileWriter) {
							this.ecpSuccessSalesForceFileWriter.write(new Chunk(salesForceSuccessList));
							this.successSalesforceNum = this.successSalesforceNum + salesForceSuccessList.size();
							LOG.info("Number of rows written to success sales force file {}", this.successSalesforceNum);
						}
					}
				} catch (final Exception e) {
					LOG.error("Exception occurred while trying to write ECP file records into file: {}", e);
					throw e;

				}
			}
		}
		LOG.debug("ECPFlatFileWriter : write() - End");
	}
}