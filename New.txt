package com.fmr.batch.ecp.listener;

import com.fmr.batch.ecp.service.S3Service;
import io.awspring.cloud.sqs.annotation.SqsListener;
import io.awspring.cloud.sqs.listener.acknowledgement.Acknowledgement;
import org.codehaus.jackson.JsonNode;
import org.codehaus.jackson.map.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.batch.core.*;
import org.springframework.batch.core.explore.JobExplorer;
import org.springframework.batch.core.launch.JobLauncher;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobParameters;
import org.springframework.batch.core.JobParametersBuilder;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.springframework.batch.core.Job;
import org.springframework.messaging.Message;


import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;

import java.util.UUID;


@Component

public class SqsMessageListener {
    private static final Logger log = LoggerFactory.getLogger(SqsMessageListener.class);

    private final ObjectMapper objectMapper = new ObjectMapper();

    @Value("${aws.sqs.queue-url}")
    private String queueUrl;

    @Value("${aws.sqs.max-messages:1}")
    private int maxMessages;

    @Value("${aws.sqs.visibility-seconds:180}")
    private int visibilitySeconds;

    @Autowired
    private  JobLauncher jobLauncher;

    @Autowired
    private  JobExplorer jobExplorer;

    @Autowired
    private  Job ecpBatch;


    @SqsListener("${aws.sqs.queue-name}")
    public void receiveMessage(Message<String> message, Acknowledgement ack) {
        try {

            String payload = message.getPayload();
            log.info("Received message:{}", payload);
            processMessage(payload, ack);

            log.info("Message processed successfully:{}", payload);

        } catch (Exception e) {
            log.error("SQS error in receiveMessage", e);
        }
    }

    void processMessage(String message, Acknowledgement ack) {
        //todo
        try {
            log.info("processing message:{}", message);
            JsonNode root = objectMapper.readTree(message);
            JsonNode records = root.path("Records");

            if (!records.isArray() || records.size() == 0) {
                log.warn("No records[] found in s3 event; skipping message{}", message);
                return;
            }
            JsonNode rec = records.get(0);
            String bucket = rec.path("bucket").path("name").asText();
            String keyEnc = rec.path("s3").path("object").path("key").asText();
            if (bucket == null || keyEnc == null) {
                log.warn("missing bucket/key in s3event;skipping message{}", message);
                return;
            }
            String Key = URLDecoder.decode(keyEnc, StandardCharsets.UTF_8);
            log.info("Event object:s3://{}/{}", bucket, keyEnc);

            System.setProperty("ECP_INPUTKEY", keyEnc);
            System.setProperty("INPUT_BUCKET", bucket);

            JobParameters params = new JobParametersBuilder()
                    .addString("jobId", UUID.randomUUID().toString())
                    .addLong("timestamp", System.currentTimeMillis()).toJobParameters();
            if(jobLauncher != null) {

                JobExecution launched = jobLauncher.run(ecpBatch, params);

                JobExecution finalState = waitForCompletion(launched.getId());

                if (finalState.getStatus() == BatchStatus.COMPLETED) {
                    ack.acknowledge();
                    log.info("Job Completed.deleted SQS message {}", message);
                } else {
                    log.warn("Job ended with status {}.keeping message {} for retry.", finalState.getStatus(), message);
                }
            }

        }catch (Exception ex) {
            log.error("Failed handling message{}.leaving it for retry.", message, ex);
        }
        try {
            Thread.sleep(1000);

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    private JobExecution waitForCompletion(Long executionId) throws InterruptedException {
        while(true){
            JobExecution current = jobExplorer.getJobExecution(executionId);
            if(current == null){
                log.warn("JobExecution{} not found in JobExplorer;breaking.",executionId);
                return new JobExecution(executionId);
            }
            if(!current.isRunning()){
                return current;
            }
            Thread.sleep(1000L);
        }
    }
}